# 操作系统

## 概述

### 概念、特征、功能

#### 操作系统的概念

计算机系统中的软件通常分为**系统软件**和**应用软件**两大类。

应用软件是指计算机用户利用计算机的软件、硬件资源为某一专门的应用目的开发的软件。例如，科学计算、工程设计、数据处理、事务处理和过程控制等方面的软件，以及文字处理软件、表格处理软件、辅助设计软件和实时处理软件等。

系统软件是计算机系统的一部分，由它支持应用软件的运行。常用的系统软件有**操作系统、语言处理程序、链接程序、诊断程序和数据库管理系统**等。

**操作系统是计算机系统中必不可少的核心系统软件，控制和管理整个计算机系统的硬件和软件资源，是用户和计算机之间的接口。**



#### 操作系统的特征

**操作系统是伴随着多道程序技术而出现的。**

**并发**：两个或者多个事件在**同一时间间隔内发生**。宏观上时同时发生的，微观上是交替进行的。

**并行**：两个或者多个事件在**同一时刻同时发生**。

作为一种系统软件，操作系统有**并发性、共享性、虚拟性、异步性的特征**。

1. **并发性**：计算机中同时运行着多个程序，这些程序宏观上看是同时运行，但微观上是交替运行。
   1. **单核CPU宏观上有多道程序同时执行，而微观上每一个时刻仅能执行一道程序，是交替发生的**。
   2. 多核CPU可以同时执行多个程序，多个程序可以**并行**。

2. **共享性**：共享指系统中的资源在一个时间段内可被多个并发执行的进程使用。
   1. **互斥共享方式**：一个时间段内，只允许一个进程访问该资源。
   2. **同时共享方式**：同时共享允许多个进程同时访问资源，如QQ和微信同时发送文件。这种情况下，进程可能会交替访问资源，如QQ和微信交替读取硬盘中的文件数据。

3. **虚拟性**：
   1. 虚拟存储器技术通过将物理内存对应为逻辑上的大内存，使得用户看到的内存容量远大于实际物理内存容量。**使用了虚拟技术中的空分复用技术**。
   2. 虚拟处理器技术让用户感受到多个CPU同时在服务，实际上是通过微小时间片的切换实现的，支持单核CPU上多个程序的并发执行。**使用了虚拟技术中的时分复用技术**。

4. **异步性**：异步性指多道程序环境下，由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进。

> 并发性和共享性是操作系统中两个互为存在条件的基本特征。没有并发性，共享性失去意义；没有共享性，并发性无法实现。



#### 操作系统的功能

**从用户和计算机之间的接口的观点来看，操作系统向上层提供的服务：GUI图形化用户接口、联机命令接口（终端）、脱机命令接口（.bat）、程序接口（编写代码中的系统调用）。**

从控制和管理整个计算机系统的硬件和软件资源的观点来看，操作系统的功能可以分为**进程管理（处理机管理）、存储管理、文件管理、设备管理和作业管理（命令接口）**5大部分。操作系统的5大部分通过相互配合、协调工作，以实现对计算机系统中资源的管理，控制任务的运行。

1. **进程管理**：实质是对处理器管理，主要任务是对进程的控制、同步、通信以及调度。
2. **存储管理**：主要任务是管理计算机内存资源。
3. **文件管理**：主要任务是有效地支持文件的存储、检索和修改等操作。
4. **设备管理**：对所有输入、输出设备的管理。
5. **接口管理**：命令接口、程序接口、图形接口。

从操作系统是计算机系统中必不可少的核心系统软件的观点来看，操作系统是对硬件机器的扩展，把计算机从裸机变为虚拟机。



### 操作系统的发展与分类

#### 操作系统的发展

操作系统从最初20世纪50年代的**手工操作**阶段，到早期的**批处理程序，再到多道批处理系统（操作系统开始出现）、分时系统、实时系统**，以及到了我们现在的的个人操作系统、网络操作系统、分布式操作系统、嵌入式操作系统、智能卡操作系统等，经历了较复杂的发展的历程。

在**手工操作阶段**，程序员通过在纸带上打孔的方式编写程序，程序运行结果通过纸带机输出，过程缓慢，且用户独占全机，资源利用率极低。随着**单道批处理系统**的引入，脱机输入输出技术得以应用，磁带替代了纸带，**监督程序控制自动从磁带中输入输出作业数据**，从而提高了输入输出速度。不过，此时内存中同一时刻只能有一道程序运行，程序之间串行执行。**多道批处理系统**的出现标志着操作系统的正式诞生，**支持多道程序并发运行**，多个程序共享计算机资源，提高了资源利用率。然而，多道批处理系统不提供人机交互功能，用户无法调试程序或输入参数。**分时操作系统**则以时间片为单位轮流为各个用户或作业服务，**允许用户通过键盘、鼠标等终端与计算机进行交互**，多个用户可以独立使用同一台计算机。尽管分时操作系统提升了用户体验，但它的缺点是无法优先处理紧急任务。**实时操作系统**根据任务**优先响应紧急任务**，分为硬实时和软实时操作系统。硬实时操作系统必须在规定时间内处理任务，否则会导致严重后果；而软实时操作系统虽不严格要求处理时间，但仍需实时显示更新信息。

此外，还有**网络操作系统、分布式操作系统和个人计算机操作系统**。网络操作系统用于管理网络资源并提供网络服务，分布式操作系统将多台计算机组成一个整体，共同完成任务，而个人计算机操作系统（如Windows、Linux等）则用于管理个人计算机的硬件和软件资源。



#### 操作系统的分类

**按照用户界面的使用环境和功能特征，分为三种：批处理系统、分时系统、实时系统**。

**Linux、UNIX系统属于多任务多用户，分时系统，是网络操作系统。**

##### 1. 批处理系统

用户将作业交给操作员，在收到一定数量的作业后，由操作员把这批作业输入到计算机，最后将结果交给用户。自动化较高，资源利用率高，作业吞吐量大，提高整个系统效率。用户不直接与计算机交互，不适合调试程序。

##### 2. 分时系统

用户通过终端交互式地向系统提出命令，系统接受命令之后，采用时间片轮转方式处理服务请求。把处理机的响应时间分成若干个大小相等的时间单位，称为时间片，每个终端用户获得 CPU，就等于获得一个时间片，该用户程序开始运行，当时间片到用完，用户程序暂停运行，等待下一次运行。

多个用户在同时使用一台计算机，用户感觉不到计算机为他人服务，系统能对用户提出的请求及时给予响应。

##### 3. 实时系统

实时系统是指系统能及时响应外部事件的请求，在规定的时间内，完成对该事件的处理，并控制所有实时任务协调一致地运行。

第一类：硬实时系统（实时过程控制），工业控制，军事控制等。

第二类：软实时系统（实时通信和信息处理），电讯（自动交换），银行，飞机订票，股市行情等。

特征：多路性、独立性、及时性、交互性和可靠性。



### 操作系统的运行环境

#### 内核态与用户态

操作系统在计算机上运行，通过执行**二进制机器指令**来实现程序逻辑。对于使用高级语言编写的程序，它们需要经过编译器编译成机器指令，才能被CPU执行。**机器指令是CPU能够识别的基本命令**，负责执行加法、赋值等基本操作。

操作系统内核包含系统最核心、必不可少的功能。内核作为系统资源管理者，执行特权指令以管理硬件资源。特权指令的使用限于内核程序，应用程序不得使用。**操作系统内核程序负责系统资源管理，而应用程序运行在操作系统之上。内核程序使用特权指令，而应用程序使用非特权指令。**

**CPU有内核态和用户态两种状态，内核态执行特权指令，用户态执行非特权指令。程序状态寄存器（PSW）的二进制位标记CPU状态，1表示内核态，0表示用户态。内核态和用户态分别对应内核程序和应用程序的执行。**

1. **内核态**：在内核态下，程序可以执行任何CPU指令，并且可以直接访问硬件资源和系统内存。此时，操作系统内核拥有完全的控制权，能够进行进程管理、内存管理、设备管理等操作。
2. **用户态**：用户态是应用程序运行的模式，此时程序受到限制，不能直接访问硬件或管理系统资源。用户态下的程序只能执行有限的指令，并通过系统调用与内核进行交互。

**切换机制**：

- **用户态到内核态**：

  - **系统调用**：应用程序通过特定的API（如`open（）`、`read（）`等）进行系统调用，请求操作系统提供服务。此时，**程序会执行一个特定的指令（如`int`指令在x86架构上）触发中断**。
  - **异常或错误**：程序在执行过程中遇到异常（如非法操作、内存访问错误）时，操作系统会自动进入内核态进行处理。
  - **中断**：硬件设备（如定时器、I/O设备）发送中断信号，操作系统会中断当前用户程序，转入内核态进行相应的处理。

- **内核态到用户态**：

  - **服务完成**：内核完成对系统调用的处理，准备将结果返回给用户程序。

  - **调度**：在多进程环境中，内核可能选择另一个用户程序进行调度，这也需要切换回用户态。

这种切换机制通过上下文切换和特权指令的控制，确保了系统的安全性和稳定性，同时允许多种程序在同一台计算机上有效运行。



#### 中断、异常

**中断是操作系统内核重新夺回CPU使用权的唯一途径**。中断会使CPU由用户态变为内核态。没有中断技术无法实现多道程序并发，甚至没有操作系统。

**内中断又称异常**，与当前执行的指令有关。

- **非法指令或非法参数**会引发内中断。
- 应用程序**执行陷入指令**（以请求操作系统服务，陷入指令不是特权指令）。

外中断与当前执行的指令无关，来源于CPU外部。**CPU在每个指令执行结束后检查外部中断信号**。

- **时钟中断，实现多道程序并发运行**。
- **I/O设备发出中断信号**，通知CPU设备操作完成。

中断处理的基本流程如下：

1. **中断信号的产生**：当外设或程序需要CPU处理时，生成中断信号。
2. **中断检测**：CPU在每个指令周期结束时检查是否有中断信号。如果有，立即响应中断。
3. **保存上下文**：CPU保存当前执行程序的状态（上下文），包括程序计数器、寄存器等，以便在中断处理完成后能够恢复执行。
4. **中断向量**：CPU使用**中断向量表（中断向量是一组指向中断处理程序的指针）找到对应中断的处理程序地址**。
5. **执行中断处理程序**：CPU跳转到中断处理程序执行，处理相关的事件或任务。
6. **恢复上下文**：中断处理完成后，CPU恢复之前保存的上下文。
7. **返回原程序**：CPU继续执行之前被中断的程序，恢复正常运行。



#### 系统调用

从用户和计算机之间的接口的观点来看，操作系统向上层提供的服务：GUI图形化用户接口、联机命令接口（终端）、脱机命令接口（.bat）、程序接口（编写代码中的系统调用）。**其中程序接口就是由一组系统调用组成**。

系统调用时操作系统给应用程序提供的接口，是应用程序获取操作系统内核服务的一种请求途径。

**系统调用与库函数的主要区别在于，库函数可能直接提供服务而无需系统调用，但某些封装基于系统调用的的操作必须通过系统调用**。

**系统调用的必要性体现在对共享资源的互斥访问管理，确保并发进程不会导致资源使用冲突**。所有与共享资源相关的操作，如内存分配与回收、IO设备访问、文件操作、进程管理、设备管理等，通常需要通过系统调用。

陷入指令（trap指令）是在用户态下执行的特殊指令，执行后会引发内中断，使CPU转入内核态运行内核程序。**陷入指令的目的是主动将CPU控制权交给操作系统内核，以请求服务。陷入指令不是特权指令**，但其执行会导致应用程序暂停，等待操作系统处理。



### 操作系统体系结构

#### 大内核 Vs. 微内核

操作系统体系结构包括大内核和微内核两种类型。内核运行在内核态。

![image-20241029100855851](https://raw.githubusercontent.com/qinshuxiang/repo/main/操作系统结构.png)

**微内核设计将只把最核心功能放在内核中，如时钟管理、中断处理、原语（不可中断），微内核设计方法是只保留与硬件关系最紧密的功能，其他功能放在内核外。微内核设计需要频繁切换CPU状态，影响系统性能。**

大内核设计包括进程管理、存储器管理、设备管理、时钟管理、中断处理、原语（不可中断）。大内核内核代码庞大，结构混乱，难以维护。大内核优点是性能高，因为应用程序请求内核服务时CPU状态转换次数少



#### 分层结构

分层结构操作系统将内核分为多层，**每层只能调用相邻的低层**。 

优点包括便于调试和验证，易于扩充和维护。**缺点包括效率低，功能需要一层层传递调用，限制了系统调用的直接性，底层无法调用高层。**



#### 模块化

模块化结构将操作系统内核划分为多个模块，各模块之间相互协作。

优点包括逻辑清晰，易于维护，**支持动态加载内核模块**。缺点包括接口定义可能不合理，模块间依赖难以调试和验证。



#### 外核

外核操作系统由内核和外核两部分组成，**外核负责分配未经抽象的硬件资源**。

**优点包括提高系统性能，减少虚拟硬件资源的映射层**。缺点包括降低系统一致性，增加系统复杂度。



### 操作系统引导

操作系统引导（OS Booting）是指计算机开机后，将操作系统从存储设备（如硬盘或SSD）加载到内存，并启动系统的过程。这个过程确保计算机硬件初始化完成后，操作系统可以正常运行。

#### **1. 上电自检（POST）**

- 计算机内存由RAM和ROM组成，RAM用于存储操作系统数据，ROM存储基本输入输出系统（BIOS）程序，用于引导操作系统，当计算机通电时，CPU从特定的主存位置开始读取指令，**BIOS**（基本输入输出系统）或**UEFI**（统一可扩展固件接口）被执行。
- **其主要任务是检测和初始化硬件（如CPU、内存、显卡、硬盘等），并确保硬件工作正常**。
- 如果检测出硬件问题，BIOS/UEFI会发出错误提示（如蜂鸣声或错误信息）。

#### **2. 引导加载程序的加载执行**

- BIOS/UEFI从预定义的引导设备（如硬盘、U盘或网络）中读取引导扇区。
  - **BIOS**：读取硬盘的**主引导记录（MBR）**，位于磁盘的第一个扇区（512字节）。
  - **UEFI**：读取**EFI系统分区**中的引导程序，如`bootx64.efi`。
- **MBR**或EFI加载的是**第一阶段引导加载程序**（如`GRUB`、`LILO`等），这是一个小型程序，用于找到并加载操作系统的内核。

#### **3. 内核加载**

- 引导加载程序定位操作系统的**内核映像**文件，并将其从存储设备加载到内存中。
- 加载内核后，将**控制权**交给内核，并开始执行内核代码。

#### **4. 系统初始化**

- 内核初始化系统的**硬件设备**，如内存管理单元（MMU）、I/O设备等。
- 内核启动必要的服务（如进程调度、文件系统管理、网络服务）。
- 启动**第一个用户进程**（如`init`或`systemd`），负责管理其他系统进程。



### 虚拟机

在计算机系统中，虚拟机是一种模拟计算机系统的软件环境，可以在物理硬件上运行多个操作系统和应用程序。虚拟机主要分为第一类虚拟机监控器和第二类虚拟机监控器。

**第一类虚拟机监控器**直接**运行在物理硬件上**，是一种裸机虚拟化技术。这类虚拟机监控器无需依赖主机操作系统，可以直接控制和管理硬件资源。虚拟机管理程序运行在最高特权级别，可以使用最高特权指令。

**第二类虚拟机监控器**运行在**主机操作系统之上**，需要依赖操作系统提供的服务和硬件访问接口。它更适合桌面环境中的开发、测试和个人用户。虚拟机管理程序部分运行在用户态，部分运行在内核态。第二类虚拟机管理程序截获上层应用程序的系统调用，并代替其向宿主操作系统发出请求

|    特点    |                    第一类 VMM                     |                          第二类 VMM                          |
| :--------: | :-----------------------------------------------: | :----------------------------------------------------------: |
|  运行层级  |                直接运行在硬件之上                 |                     运行在 Host OS 之上                      |
|  资源分配  |          自行分配未经抽象的物理硬件资源           |               依赖于 Host OS 为其分配物理资源                |
|  虚拟磁盘  |          在原本的硬盘上自行分配存储空间           | 拥有自己的虚拟磁盘，实际上是 Host OS 文件系统中的一个大文件  |
|  虚拟内存  |              直接控制和分配物理资源               |               Guest OS 分配到的内存是虚拟内存                |
|    性能    |        性能更好，不需要和 Host OS 竞争资源        |              性能较差，需要 Host OS 作为"中介"               |
| 虚拟机数量 |        相同的硬件资源可以支持更多的虚拟机         | 相对更少，Host OS 本身需要使用物理资源，Host OS 上运行的其他进程也需要物理资源 |
|   迁移性   |                       更差                        | 更好，只需导出虚拟机镜像文件即可迁移到另一台 Host OS 上，商业化应用更广泛 |
|   特权级   | 运行在最高特权级（Ring0），可以执行最高特权的指令 | 部分运行在用户态、部分运行在内核态，Guest OS 发出的系统调用会被 VMM 截获，并转化为 VMM 对 Host OS 的系统调用 |



## 进程管理

### 进程与线程 

#### 进程概念

**进程由PCB、程序段（指令集合）、数据段（程序运行产生变量）组成。**

PCB是进程存在的唯一标志，进程的创建、销毁都会伴随操作系统创建、回收PCB。

- **进程描述信息**：进程标识符PID、用户标识符UID
- **进程控制和管理信息**：CPU、磁盘、网络流量使用情况，进程当前状态：就绪态、运行态、阻塞态
- **资源分配清单**：正在使用文件、正在使用内存区域、正在使用I/O设备
- **处理机相关信息**：PSW、PC等各种寄存器的值（用于实现进程切换）

进程的特征：

1. **动态性**：进程是程序的一次执行过程，进程是动态产生、变化和消亡的。
2. **并发性**：多个进程实体在内存中，各进程并发执行。
3. **独立性**：进程时能够独立运行、获得资源、接受调度的基本单位。
4. **异步性**：进程以各自独立的速度向前推进。
5. **结构性**：每个进程都有一个PCB、程序段和数据段。



#### 进程的状态与转换

进程的状态包括创建态、就绪态、运行态、阻塞态和终止态。 

- 创建态：进程正在被创建，操作系统**分配系统资源并初始化PCB**。
- 就绪态：进程具备运行条件，等待CPU空闲。
- 运行态：进程正在CPU上运行。
- 阻塞态：进程等待某个事件发生。
- 终止态：进程运行结束，操作系统**回收资源并撤销PCB**。

![image-20241029112138873](https://raw.githubusercontent.com/qinshuxiang/repo/main/进程的状态转换.png)

进程的组织方式

- 链式方式:
  - 在内存中，**每个进程控制块（PCB）通过指针链接到下一个进程控制块**。
  - 形成一个单向链表，链头指向就绪队列的首进程，链尾指向最后一个进程。
  - 这种方式便于进程的插入和删除操作，但需要顺序搜索整个链表。
- 索引方式:
  - 利用一张索引表，表中的每一项对应一个进程控制块在内存中的地址。
  - 通过索引表可以直接找到对应进程控制块的位置，不需要遍历整个链表。
  - 这种方式查找速度快，但需要额外维护一张索引表，占用更多内存空间。



#### 进程控制

进程控制包括创建新进程、撤销已有进程、实现进程状态转换等功能，**核心是实现进程的状态转换**。

**进程控制需要用原语来实现，原语是操作系统内核中的特殊程序，具有原子性，原语的执行必须一气呵成，中间不可被中断。**

关中断指令：执行后，CPU不再例行检查中断信号。开中断指令：执行后，CPU恢复例行检查中断信号。**关中断和开中断指令中间的指令序列执行不可被中断，运行在内核态。**

- **进程创建原语**：首先需要申请空白PCB，然后为新进程分配资源，初始化PCB，最后将PCB插入队列。引起进程创建的情况：用户登录，作业调度、提供服务、应用请求。
- **进程撤销原语**：进程撤销时需要找到该进程的PCB，若进程正在运行，需剥夺其CPU使用权，将CPU分配给其他进程，父进程被撤销时，其子进程也会被终止，撤销进程后，其占有的资源需归还给父进程，最后将进程的PCB从系统中删除。
- **堪称阻塞原语**：找到进程对应的PCB，保护进程运行现场，将PCB设置为阻塞态，插入等待队列。
- **进程唤醒原语**：将PCB从等待队列移除，设置为就绪态，插入就绪队列。
- **进程切换原语**：保存运行环境，将进程的运行环境信息存入PCB，PCB移动到相应队列，挑选新进程，更新其PCB的内容，从PCB中恢复进程的运行环境。

其中**阻塞原语和唤醒原语必须成对使用**。

> 寄存器：CPU中用于存放指令和数据的地方。
>
> 程序状态寄存器（PSW）：储存当前进程的状态。
>
> 程序计数器寄存器（PC）：存放接下来要执行的指令的地址。
>
> 指令寄存器（IR）：存放当前CPU正在执行的指令.
>
> 通用寄存器：存放其他必要的信息。
>
> 运行环境：进程在运行过程中寄存器中存储的中间结果。 保存运行环境：将进程的运行环境信息保存到PCB中。恢复运行环境：从PCB中恢复进程的运行环境。
>



#### 进程通信

进程是分配系统资源的单位，各进程之间拥有的内存地址相互独立，为保障安全，一个进程只可以访问自己的内存地址。

**进程通信（IPC）**是指两个进程之间产生数据交互。**进程间通信需要操作系统的支持**。

##### 1. 共享存储系统

**一个进程可以向操作系统申请共享存储区，并被其他进程共享**，进程间传送数据需要通过一个进程先写入共享存储区，然后另一个进程从该区域读取数据。**多个进程访问共享存储区需要保证互斥**，操作系统提供同步互斥工具如PV操作。

基于数据结构的共享方式灵活性低，速度慢。**基于存储区的共享方式灵活性高，速度快。**

##### 2. 消息传递系统

进程通信以格式化的信息为单位，进程通过**操作系统提供的“接受 / 发送”原语**进行数据交互。**格式化消息由消息头和消息体组成，消息头包含发送者、接收者和消息长度等信息。**

消息传递可分为直接**通信方式**（发送进程指明接收进程的ID，操作系统将消息**挂入接收进程的消息队列**）和**间接通信**方式（**通过信箱进行通信**，发送进程将消息发送到信箱，接收进程从信箱接收消息）。

##### 3. 管道通信

管道通信类似于水管，数据从一端写入，从另一端读出，数据流向只能是单向的。管道是操作系统创建的特殊共享文件，**本质上是大小固定的内存缓冲区**，管道读写数据**遵循先进先出的规则**，是一个循环队列，管道通信支持**半双工通信**，**需要读写进程互斥访问管道**，管道被写满时，写进程被阻塞；管道被读空时，读进程被阻塞。



#### 线程概念与多线程模型

**引入线程机制后，进程是资源分配的基本单位，线程是调度的最小单位**。同一进程内的线程共享进程的资源（代码段、数据段、文件等），每个线程有自己的线程ID和**线程控制块TCB**，程序计数器、寄存器和栈空间，线程创建和切换开销小于进程。

**用户级线程模型（多对一）**：**用户级线程由应用程序的线程库实现**，线程库管理线程的创建、销毁和调度，**可以在不支持线程的操作系统上实现**，线程切换在用户态下完成，不需要CPU状态转换，**线程切换不需要内核模式切换，速度快**，操作系统感知不到用户级线程的存在，一个线程阻塞会导致整个进程阻塞。

**内核级线程模型（一对一）**：内核级线程由操作系统实现，是操作系统可见的线程，**线程创建、调度和管理由内核完成**，内核级线程是处理机调度的基本单位，多核CPU下，线程可以并行执行，**一个线程阻塞不会影响其他线程**。

**线程控制块(TCB)是操作系统管理线程的核心数据结构**，它包含了线程运行所需的所有重要信息。每个TCB都包含线程标识符(TID)用于唯一标识线程，程序计数器(PC)指示当前执行位置，其他寄存器用于保存运行时的中间结果。同时，TCB中的堆栈指针负责维护函数调用信息和局部变量，线程运行状态反映当前是运行、就绪还是阻塞状态，而优先级则用于线程调度和资源分配决策。**系统将多个TCB组织在一张线程表中进行统一管理**，在线程切换时需要保存和恢复TCB中的上下文信息，这确保了线程能够在被中断后正确恢复执行。这种组织结构与进程控制块(PCB)类似，但专注于线程级别的管理，是操作系统进行线程调度和管理的基础。



### 处理机调度 

#### 调度的基本概念

调度就是指当我们有一堆任务要处理的时候，由于当前的资源有限，这些事情没办法同时的被处理，这个时候我们就需要按照某种规则，比如说先到先服务或者说时间短的优先这样各种这样的规则来决定我们要用什么样的顺序来处理这些任务。

#### 调度的三个层次

##### 1. 高级调度

作业就是具体的一个任务。

高级调度也称为作业调度，指按照一定的原则**从外存的作业后备队列中挑选一个作业调入内存，并创建进程**。

##### 2. 低级调度

**低级调度也称为进程调度**、处理机调度，指按照某种策略**从就绪队列中选取一个进程，将处理机分配给他**。

**是操作系统中最基本的一种调度方式。**

##### 3. 中级调度

中级调度又称为内存调度，指按照某种策略决定将哪一个处于**挂起队列的进程重新掉入内存**。

##### # 对比总结


![image-20241030175559343](https://raw.githubusercontent.com/qinshuxiang/repo/main/进程挂起的七状态模型.png)


| 调度类型               | 要做什么                                                     | 调度发生在              | 发生频率 | 对进程状态的影响                   |
| ---------------------- | ------------------------------------------------------------ | ----------------------- | -------- | ---------------------------------- |
| 高级调度<br>(作业调度) | 按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程 | 外存→内存<br>(面向作业) | 最低     | 无→创建态→就绪态                   |
| 中级调度<br>(内存调度) | 按照某种规则，从挂起队列中选择合适的进程将其数据调回内存     | 外存→内存<br>(面向进程) | 中等     | 挂起态→就绪态<br>(阻塞挂起→阻塞态) |
| 低级调度<br>(进程调度) | 按照某种规则，从就绪队列中选择一个进程为其分配处理机         | 内存→CPU                | 最高     | **就绪态→运行态**                  |



#### 调度时机、切换与过程

进程可能发生调度的时机

- 当前进程主动放弃处理机
  - 进程正常终止
  - 发生异常而终止
  - 主动请求阻塞（IO处理）
- 当前进程被动放弃处理机
  - 分给进程的时间片用完
  - 有更紧急的事需要处理（IO中断）
  - 有更高优先级的进程进入就绪队列

不能进行进程调度的时机

- 在处理中断的过程中
- 进程在操作系统内核程序临界区中，但是在普通的临界区可以进行进程调度
- 原语操作过程中

> 临界资源：一段时间内只允许一个进程访问的资源，各进程需要互斥的访问临界资源。
>
> **对临界资源的互斥访问逻辑上可以分为：进入区（上锁）、临界区（实际代码）、退出区（解锁）、剩余区。**
>
> 内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列



#### 调度方式

非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。**适合批处理系统。**

剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。**适合分时、实时操作系统。**



#### 度的基本准则

狭义的**进程调度**指的是从就绪队列中**选中一个**要运行的进程。

广义的**进程调度**包含了**选择一个进程和进程切换**两个步骤。

**进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。**

进程切换的过程主要完成了:

1. 对原来运行进程各种数据的保存
2. 对新的进程各种数据的恢复(如:程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块)

注意：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。

**调度程序决定让谁运行（调度算法）以及运行多少时间（时间片大小）。**

非抢占式调度策略，只有运行进程阻塞或退出才触发调度程序工作。

抢占式调度策略，每个时钟中断或k个时钟中断会触发调度程序工作。

当没有其他进程的时候，运行闲逛进程。优先级最低，能耗低



#### 调度算法评价指标

`CPU利用率 = 忙碌时间 / 总时间`

`系统吞吐量 = 总共完成多少个作业 / 总共花费时间`

`周转时间 = 作业完成的时间 - 提交给系统的时间 `

`平均周转时间 = 各作业周转时间之和 / 作业数`

`带权周转时间 = 作业周转时间 / 作业实际运行时间`

`等待时间 = 等待处理机状态之和 + 作业在外存中等待的时间`

`响应时间 = 提交请求到首次响应产生的时间`



#### 典型调度算法 

##### 先来先服务调度算法

按照进程到达的顺序进行调度，最先到达的进程最先执行。一般是非抢占式算法。不会导致饥饿。

**优点**：简单易实现，适用于对时间顺序敏感的任务。

**缺点**：可能导致较长作业会延迟后续短作业的执行。

##### 短作业优先调度算法

优先执行估计运行时间最短的进程。一般是非抢占式算法。可能会导致饥饿。

**优点**：能够减少平均等待时间，效率较高。

**缺点**：难以准确预测进程的运行时间，可能导致长作业的“饥饿”问题。

##### 高响应比优先调度算法

根据响应比（等待时间 与 估计运行时间的比值）来调度进程。响应比越高的进程优先执行。一般是非抢占式算法。不会导致饥饿。

**优点**：综合考虑了等待时间和服务时间，能够平衡不同类型进程的需求。

**缺点**：实现复杂，需要动态计算响应比。

##### 时间片轮转调度算法

为每个进程分配一个固定时间片，时间片用完后将进程放回队列末尾。抢占式算法。不会导致饥饿。

**优点**：公平性好，适合时间共享系统，能有效提高响应速度。

**缺点**：时间片过长可能导致低效率，过短则增加上下文切换的开销。

##### 优先级调度算法

为每个进程分配一个优先级，优先级高的进程优先执行。有抢占式算法有非抢占式系统。会导致饥饿。

**优点**：可以针对特定进程提供更高的服务。

**缺点**：可能导致低优先级进程的“饥饿”问题，且需要合理的优先级分配机制。

##### 多级反馈队列调度算法

使用多个队列，每个队列有不同的优先级和时间片。进程可以根据其表现在队列之间移动。抢占式算法。会导致饥饿。

**优点**：灵活且高效，能够适应多种进程类型的需求。

**缺点**：实现复杂，配置多个队列和调度策略可能导致管理上的困难。



### 同步与互斥

#### 进程同步的基本概念

同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。

**我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。对临界资源的访问，必须互斥地进行。**互斥，亦称间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。

为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：**当临界区空闲时，允许一个请求进入临界区的进程立即进入；如果已有进程进入临界区，其他试图进入的进程必须等待；对请求访问的进程，必须保证在有限时间内能够进入临界区，以防止饥饿现象的发生；如果进程无法进入临界区，应主动释放处理机，防止进程陷入忙等状态。**



#### 实现临界区互斥的基本方法

##### 软件实现方法

**单标志法**：**通过一个标志变量来表示临界区是否被占用**。当一个进程要进入临界区时，先检查标志变量，如果标志变量未被占用，则进程设置该标志并进入临界区；退出时清除标志。不适用于多个进程的情况，因为当多个进程同时检查标志变量时，**可能会出现竞争条件，导致临界区无法有效互斥。**

**双标志先检查**：使用两个标志变量，每个进程有一个标志，用于表示是否希望进入临界区。当进程想要进入临界区时，首先检查对方的标志，如果对方不希望进入临界区，才将自己的标志设置为需要进入，然后进入临界区。**可能会导致“死锁”现象，即两个进程都并发运行检查对方的标志并等待，导致相互阻塞而无法进入临界区。**

**双标志后检查**：与双标志先检查类似，不同的是，进程在设置自己的标志后再检查对方的标志变量，以决定是否进入临界区。**虽然可以避免死锁，但仍可能导致“忙等”（即两个进程不断检查对方标志，但都无法进入临界区）。**

**Peterson算法**：是一种经典的互斥算法，能够有效解决两个进程的互斥问题。该算法使用两个标志变量和一个“turn”变量。每个进程在想要进入临界区时，首先设置自己的标志表示想要进入，**并将“turn”设置为对方**。然后检查对方的标志和“turn”值来决定是否进入临界区。



##### 硬件实现方法

**中断屏蔽**：在单处理器系统中，进程进入临界区时，禁止所有中断。这样操作系统不会被打断，避免了其他进程在其执行期间进入临界区。完成后，再重新开启中断。**仅适用于单处理器系统**，因为在多处理器系统中，仅禁用当前处理器的中断无法阻止其他处理器访问临界区。此外，长时间禁用中断会影响系统性能和响应性。

**Test-and-Set指令**：Test-and-Set是一种原子操作（不可分割的操作），能够检测并修改一个内存位置的值。它通常与一个布尔变量（锁）一起使用。进程通过Test-and-Set指令检查锁的状态，如果锁是“未占用”状态，则将其设置为“占用”并进入临界区。离开临界区时，将锁清空。

**Swap指令**：Swap指令可以交换两个内存位置的值，也是原子操作。两个进程使用一个共享的布尔变量作为锁。当一个进程想要进入临界区时，它用Swap指令将锁变量交换为“占用”状态。如果成功进入，则表示获取到锁。



#### 互斥锁

**解决临界区最简单的工具就是互斥锁(mutex lock)**。一个进程在进入临界区时应获得锁;在退出临界区时释放锁。函数 acquire获得锁，而函数 release释放锁。每个互斥锁有一个布尔变量 available，表示锁是否可用。如果锁是可用的，调用 acqiure会成功，锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。

**互斥锁的主要缺点是忙等待**，当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用 acquire。因此，互斥锁通常用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行。

需要连续循环忙等的互斥锁，都可称为自旋锁(spin lock)，如 TSL指令、swap指令、单标志法。



#### 信号量

整形信号量



纪录型信号量



#### 管程



#### 经典同步问题

##### 生产者-消费者问题



##### 读者-写者问题



##### 哲学家进餐问题



### 死锁 

#### 死锁的概念

**死锁**：是指多个进程因竞争资源而造成的一种僵局现象，若无外力的作用，这些进程都不能继续执行。死锁进程至少有两个。

死锁的原因：

1. **竞争资源**：当系统中供多个进程共享的资源不足以同时满足它们的需求时，引起它们对资源的竞争而产生死锁。
2. **进程推进顺序不合理**：进程在运行过程中，请求和释放资源的顺序不当，会导致进程死锁。

**活锁**：是指数据资源释放时间不确定，导致某些事务长时间等待，得不到封锁的机会。

**饥饿**：是指系统没有发生死锁，但某些进程可能会长时间等待，当等待时间给进程推进和响应带来明显影响时，称进程饥饿。



#### 死锁处理策略



#### 死锁预防



#### 死锁避免

##### 系统安全状态



##### 银行家算法



#### 死锁检测和解除



## 内存管理

### 内存管理基础 

#### 内存管理概念 

##### 程序装入与链接

**计算机系统中的存储器可分成两类：内存、外存**。

**处理器可以直接访问内存，但不能直接访问外存**。CPU要通过启动相应的I/0设备后才能使外存与内存交换信息。内存管理是操作系统的重要功能之一，对内存管理的好坏直接影响计算机系统工作性能的高低。

存储系统三要素：容量、速度、成本。



##### 逻辑地址与物理地址空间



##### 内存保护



#### 交换与覆盖



#### 连续分配管理方式



#### 非连续分配管理方式

##### 分页管理方式



##### 分段管理方式



##### 段页式管理方式



### 虚拟内存管理 

#### 虚拟内存基本概念



#### 请求分页管理方式



#### 页面置换算法

##### 最佳置换算法（OPT）



##### 先进先出置换算法（FIFO）



##### 最近最少使用置换算法（LRU）



##### 时钟置换算法（CLOCK）



#### 页面分配策略



#### 工作集



#### 抖动



## 文件管理

### 文件系统基础

#### 文件概念

**操作系统必须提供的数据存储、数据处理、数据管理的基本功能，这些功能都是以文件形式进行处理和管理的。文件系统是操作系统的一个重要组成部分。**

文件是指存放在存储介质上的已命名的一组相关信息的集合，通常将程序和数据组织成文件。文件中的基本访问单位是位、字节或记录。文件的属性包括文件类型、文件长度、文件的物理位置、文件的存取控制、文件的建立时间。文件是一种抽象机制，它提供了一种把信息保存在存储介质上而且便于以后存取的方法，用户不用关心文件的实现细节。

文件系统是操作系统中统一管理信息资源的一种软件。它管理文件的存储、检索、更新，提供安全可靠的共享和保护手段，并且方便用户使用。从用户的角度，**文件系统实现“按名存取”，通过文件目录查找**，主要关心文件由什么组成，如何命名，如何保护，如何操作等。

**按文件的用途分类**：系统文件、库函数文件、用户文件。

**按文件的组织形式分类**：普通文件、目录文件、特殊文件。

**按文件中的保护方式分类**：只读文件、读写文件、可执行文件、无保护文件等。

按照文件的组织结构分类：

- **逻辑结构：无结构的流式文件和有结构的记录式文件。**
- **物理结构：顺序文件、链接文件和索引文件。**



**文件目录是指存放文件有关信息的一种数据结构**。它包含多条记录，每条记录为一个文件的**文件控制块（FCB）**的有关信息。最简单的记录包含文件名和文件的起始地址，用以建立文件名和存储地址的对应关系。文件目录是文件实现按名存取的重要手段，是文件符号名到文件物理地址之间的一种映射机制。

文件控制块FCB：是文件存在的标志，记录了系统管理文件所需要的全部信息，包括**文件名**、文件号、用户名、文件物理地址、文件长度、记录大小、文件类型、文件属性、共享说明、文件逻辑结构、物理结构、文件的建立时间、最后访问时间、最后修改时间、保存期限、口令等。



**操作系统通过 FCB 文件管理** 



Windows系统中，用户A对一个文件有读、写的权限，而A对于这个文件所在的文件夹只有读权限，用户A最终对这个文件将具备读权限。

数字表示不同用户或用户组的权限。第一个数字代表档案拥有者，第二个数字代表群组，第三个数字代表其他。在Linux中我们有三种常用权限：可读、可写以及可执行，用数字表示的话就是：可读=4，可写=2，可执行=1。



文件保护是指避免由于自然灾祸、系统故障、用户使用不当等原因使文件遭到破坏或丢失的现象。文件系统通常采用**建立副本、定时转储、规定文件的存储权限**的方法保护文件。

文件保密是指文件本身不得被未授权的用户访问，即防止他人窃取文件。实现文件保密采用的方法有：隐藏文件目录、设置口令、文件加密。



#### 文件的逻辑结构

 ##### 顺序文件



##### 索引文件



##### 索引顺序文件



#### 目录结构 

##### 文件控制块和索引节点



##### 单级目录结构和两级目录结构



##### 树形目录结构



##### 图形目录结构



#### 文件共享 



#### 文件保护

##### 访问类型



##### 访问控制



### 文件系统实现

#### 文件系统层次结构



#### 目录实现



#### 文件实现



### 磁盘组织与管理 

#### 磁盘的结构



#### 磁盘调度算法



#### 磁盘的管理



## 设备管理

### I/O 管理概述

#### I/O 控制方式

IO设备又称外部设备，主要功能是数据的输入和输出。**Unix系统将外部设备抽象为特殊文件，用户可通过读文件或写文件的方式操作外部设备。**

**按使用特性分类：人机交互类外部设备、存储设备和网络通信设备。**

按传输速率分类：低速设备、中速设备和高速设备。

**按信息交换单位分类：块设备（传输速率高，可寻址）和字符设备（常采用中断驱动方式）**。

CPU无法直接控制IO设备的机械部件，必须通过电子部件间接控制。主要功能包含接受和识别CPU发出的命令（控制寄存器）、向CPU报告设备的状态（状态寄存器）、数据交互（数据寄存器）、地址识别。

IO控制器分为三个部分：

CPU与控制器的接口、IO逻辑 和 控制器与设备之间的接口。CPU与控制器的接口用于完成CPU和控制器之间的通信，IO逻辑负责接收和识别CPU的命令，并将其翻译成设备能理解的命令，控制器与设备之间的接口用于完成控制器和设备之间的通信。



#### I/O 软件层次结构



### I/O 核心子系统

#### I/O 调度概念



#### 高速缓存与缓冲区



#### 设备分配与回收



#### 假脱机技术
