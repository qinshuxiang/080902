# 数据结构

**算法 + 数据结构 = 程序。**

## 基础知识

### 数据的概念

数据：即信息的载体，是对客观事物的符号表示，指能输入到计算机中并被计算机程序处理的符号的总称。整数，实数，字符，文字，声音，图形，图像等都是数据。

数据元素：**是数据的基本单位**，一般由一个或多个数据项组成。数据项是不可分割的、含有独立意义的最小数据单位。

数据项：数据元素中的**单个字段或属性**。 

数据结构：是反映数据元素之间存在一种或多种特定关系的数据元素的集合的表示，即带有结构的数据元素的集合。

数据类型：值的集合和定义在**集合上**的一组**操作的总称**。

原子类型：**值不可再分**的数据类型，如布尔类型、int类型。

结构类型：值可以再分解成若干个分量的数据类型，如结构体。

抽象数据类型：抽象数据组织和与之相关的操作。定义抽象数据类型时，**不关心具体存储结构，只关心逻辑结构和数据运算**。



### 数据结构三要素

#### 逻辑结构

逻辑结构分类：集合、线性结构、树形结构、图状结构。



#### 物理结构

物理结构分类：顺序存储、链式存储、索引存储、散列存储。

顺序存储：数据元素在物理上必须是**连续的**。

非顺序存储：数据元素在物理上必须是**离散的**。



#### 数据运算

根据数据的逻辑结构定义需要的运算，不同存储结构下，数据运算的实现方式不同。



### 算法

算法是对特定问题求解步骤的一种描述，是用来解决某个问题的一些指令的集合。它是指令的有限序列，其中每条指令表示一个或多个操作。算法的特性：**有穷性、确定性、可行性、输入和输出**。评价算法优劣标准：**正确性、可读性、健壮性、高效率与低存储量需求**。

**时间复杂度：度量算法执行时间的多少。** 

简化时间复杂度表达式：忽略低阶部分和常数项。多项相加时只保留最高阶的项，相乘时合并为一项。

![image-20241027193414518](https://raw.githubusercontent.com/qinshuxiang/repo/main/算法的时间复杂度.png)

$O(1) \rightarrow O(\log_2 n) \rightarrow O(n) \rightarrow O(n \log_2 n) \rightarrow O(n^2) \rightarrow O(n^3) \rightarrow O(2^n) \rightarrow O(n!)$

**空间复杂度：度量算法执行过程中的内存开销。**空间复杂度是指算法在计算机内执行时所需存储空间的度量。算法执行期间所需要的存储空间包括3个部分：**算法程序所占的空间、输入的初始数据所占的存储空间、算法执行过程中所需要的额外空间**。

算法执行时，需要内存存放局部变量和参数。执行过程中所需的内存空间大小是固定不变的常数值。

如果算法所需的内存空间与问题规模n无关，则称该算法可以原地工作。

函数递归调用会导致内存开销的增加，一般递归调用的空间复杂度为O(n)。



## 线性表

数据元素之间的关系有两种不同的表示方法：顺序映象和非顺序映象，并由此得到两种不同的存储结构：**顺序存储结构和链式存储结构**。在计算机中用一组地址连续的存储单元依次存储线性表的各个数据元素，称作**线性表的顺序存储结构**。

线性表是由相同数据类型的n个数据元素组成的有限序列，数据元素之间有线性关系，每个元素有唯一的位序。

**线性表有一个开始节点和一个结束节点，其余的内部节点有且仅有一个直接前驱和一个直接后继。**

线性表的顺序存储结构：数组，数组的存储空间是连续的，元素在存储空间按照逻辑顺序依次存放。

线性表的链式存储结构：链表，有单链表，循环链表，双向链表、静态链表。



## 栈、队列、数组

**栈的进出原则，先进后出**

**队列栈的进出原则，先进先出**



## 串

串（字符串）是由字符组成的有限序列，每个字符串都有一个名字（串名），以及字符的数量（串长度）。



## 树与二叉树

二叉树是一种特殊的树形数据结构，每个节点最多只能有两个子节点（通常称为左子节点和右子节点）。

1. 二叉树第 i 层上至多含有 `2^(i - 1)`个节点。
2. 深度为 k 的二叉树至多含有`2^k - 1 `个节点
3. 对于任意一棵二叉树，度为0的节点比度为2的节点多一个。`n_0 = n_2 + 1`

**完全二叉树**：除了最底层外，每一层都被完全填满，并且最底层的节点尽量向左对齐。完全二叉树只有最后两层可能出现叶子节点。

**满二叉树**：满二叉树的每一层都被完全填满。

**平衡二叉树**：**左子树**节点的值 < 当前节点的值。**右子树**节点的值 > 当前节点的值。

**排序二叉树**：是一种**自平衡**的二叉搜索树，确保任意节点的左右子树高度差不超过1。这保证了树的高度尽量小，避免极端情况下退化为链表。

**遍历方式**：二叉树的遍历方式有：

- **前**序遍历（**根**->左->右）
- **中**序遍历（左->**根**->右）
- **后**序遍历（左->右->**根**）
- 层序遍历（按层访问）

已知前序遍历ABCDEF，中序遍历CBAEDF，后序遍历解法

```javascript
A			A
B		B
C C
D					D
E				E
F						F
	C	B	A	E	D	F
// 后序遍历结果：CBEFDA 
```

已知后序遍历DABEC，中序遍历DEBAC，前序遍历解法

```javascript
C					C
E		E
B			B	
A				A
D	D
	D	E	B	A	C
// 前序遍历结果：CEDBA 
```

**堆**是一种完全二叉树（完全填满，除了最后一层可以不完全），分为：

- **大顶堆**：每个节点的值都大于或等于其子节点的值。
- **小顶堆**：每个节点的值都小于或等于其子节点的值。

![img](https://raw.githubusercontent.com/qinshuxiang/repo/main/堆.png)



## 图

图是一种非线性数据结构，由一组顶点（或称为节点）和一组边组成。图结构广泛应用于计算机科学和其他领域，如社交网络、地图导航和推荐系统等。

**顶点：**图中的基本单位，代表实体。例如，在社交网络中，顶点可以代表用户。

 **边**

- 连接两个顶点的线，可以是有向的或无向的。
- 有向边：表示从一个顶点指向另一个顶点。
- 无向边：表示两个顶点之间的双向关系。

**权重**：边的权重可以表示距离、成本、时间等，用于加权图。

**图的遍历**：

- **深度优先搜索（DFS）**：从一个顶点开始，沿着边尽可能深入到每个分支再回溯。
- **广度优先搜索（BFS）**：从一个顶点开始，先访问邻接顶点，然后依次访问邻接的邻接顶点。



## 查找

顺序查找，用于线性表，从头到尾依次查找。

适用于有序的顺序表，如果中间项 `mid = (low + high) // 2` 向下取整，在使用二分法（Binary Search）查找时，比较的最大次数应为 $k = \lceil \log_2{n} \rceil$，向上取整。

**举例：**

- 如果数组长度为 $n = 16$，则 $\log_2{16} = 4$，最大比较次数为 $4$。
- 如果数组长度为 $n = 10$，则 $\log_2{10} \approx 3.32$，向上取整为 $4$ 次。

分块查找主要用于静态顺序表，结合了顺序查找和分块的思想，目的是提高查找效率。

- **原数组**：`[10, 20, 30, 40, 50, 60, 70, 80, 90]`
- **分块**：`[10, 20, 30]`, `[40, 50, 60]`, `[70, 80, 90]`
- **块的信息**：`min: [10, 40, 70]`, `max: [30, 60, 90]`
- 根据要查找的元素值，通过比较最小值和最大值来确定目标元素可能所在的块。在确定的块内进行顺序查找，以找到目标元素。







## 排序

### 冒泡排序

![冒泡排序](https://raw.githubusercontent.com/qinshuxiang/repo/main/冒泡排序.gif)

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。



### 选择排序

![选择排序](https://raw.githubusercontent.com/qinshuxiang/repo/main/选择排序.gif)

1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
2. **再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。**
3. 重复第二步，直到所有元素均排序完毕。



### 插入排序

![插入排序](https://raw.githubusercontent.com/qinshuxiang/repo/main/插入排序.gif)

1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）



### 希尔排序

![希尔排序](https://raw.githubusercontent.com/qinshuxiang/repo/main/希尔排序.gif)

1. 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；
2. 按增量序列个数 k，对序列进行 k 趟排序；
3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。



### 归并排序

![归并排序](https://raw.githubusercontent.com/qinshuxiang/repo/main/归并排序.gif)

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；
4. 重复步骤 3 直到某一指针达到序列尾；
5. 将另一序列剩下的所有元素直接复制到合并序列尾。



### 快速排序

![快速排序](https://raw.githubusercontent.com/qinshuxiang/repo/main/快速排序.gif)

1. 从数列中挑出一个元素，称为 “基准”（pivot）;
2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；

## 补充

Bloomfilter是由HowardBloom在1970年提出的二进制向量数据结构，它具有空间和时间效率，被用来检测一个元素是不是集合中的一个成员。如果检测结果为是，该元素**不一定**在集合中；但如果检测结果为否，该元素**一定不**在集合中。当插入的元素越多，错判“在集合内”的概率就越大。**Bloomfilter不能删除一个元素**，多个元素哈希的结果可能在Bloomfilter结构中占用的是同一个位，如果删除了一个比特位，就会影响多个元素的检测。

