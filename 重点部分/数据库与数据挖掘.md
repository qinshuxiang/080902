# 数据库与数据挖掘

## 数据库

### 数据库系统

数据管理技术经过了**人工管理、文件系统和数据库系统**三个阶段。

| 缩写 | 说明 |
| ---- | ---- |
| DB   | 数据库 |
| DBA | 负责数据库管理和维护的专业角色 |
| DBMS | **数据库管理系统，进行数据库的统一管理，属于系统软件，位于用户与操作系统之间，调用操作系统** |
| DBS  | 数据库系统，泛指由数据库、DBMS 以及相关应用程序构成的整体系统 |

数据库管理系统的功能：

| 功能 | 描述 |
| ---- | ---- |
| **数据定义 DDL** | **定义数据库的结构**，包括表、字段、数据类型等。 |
| **数据操纵 DML** | 支持数据的**增、删、改、查**等基本操作。 |
| 数据安全 | 保护数据不被未授权访问，提供**用户权限管理**。 |
| 数据完整性 | **确保数据的准确性和一致性**，包括约束条件（如主键、外键等）。 |
| 数据备份与恢复 | **提供数据备份和恢复机制**，以防数据丢失或损坏。 |
| 数据共享 | 允许多个用户或应用程序同时访问和操作数据，支持**并发控制**。 |
| 数据库通信 | 提供与系统的接口，支持数据交换和集成。 |



### 数据模型

#### 数据模型

数据模型是数据库结构的基础，是用来描述数据的一组概念和定义。数据模型的三要素是**数据结构、数据操作、数据完整性约束**。常用的数据模型分为：

1. **概念数据模型**：是对真实世界中问题域内的事物的描述。最著名的就是**实体一联系模型(E-R模型)**。
2. **基本数据模型**：是按计算机的观点对数据建模，是现实世界数据特征的抽象。基本数据模型有：**层次模型、网状模型、关系模型**。

数据库的三级模式和两级映像是数据独立性的重要概念。三级模式包括：

1. **内部模式**：物理存储结构，可以看为**文件**。
2. **概念模式**：整个数据库的逻辑结构，描述数据的关系，可以看为**表**。
3. **外部模式**：用户**视图**，不同用户对数据的不同视角。

两级映像则是指：

1. **概念模式到内部模式的映像**：逻辑数据结构如何映射到物理存储。
2. **外部模式到概念模式的映像**：用户视图如何映射到数据库的逻辑结构。

#### ER模型

ER模型（实体-关系模型）是用于数据库设计的图形化工具，主要用于表示数据及其关系。以下是ER模型的基本构成要素：**实体、属性、关系**。

表示方式：**实体**：方框，**联系**：菱形，**属性**：椭圆，其中联系可以是一对一、一对多、多对多。

> **例**：10个实体，12个二元联系，包含3个一对一联系，4个一对多联系，5个多对多联系
>
> 主键：10 + 5 = 15 （**实体数 + 多对多关系数**）
>
> 外键：3 + 4 + 10 = 17（**外键是由联系产生，一对一或一对多有一个外键，多对多有两个外键**）

#### 关系模型

关系模型，是指用二维表的形式表示实体和实体间联系的数据模型，它是目前数据库最重要的逻辑数据模型。关系型数据库采用关系模型作为数据的组织形式。关系模型主要由**关系数据结构、关系操作集合和关系完整性约束组成**。基本术语：

1. 属性：在二维表中的列(字段、数据项)；列值称为属性值。
2. 元组：关系在二维表中的行。
3. 关键字：能够用来唯一表示元组的属性(或属性组合)。在一个关系中，**关键字的值一定不能为空**。
4. 如果在一个关系中，存在多个属性或属性组合都能唯一表示该关系的元组，则这些属性或属性组合都称为该关系的**候选关键字**。
5. 在一个关系的若干个候选关键字中指定作为关键字的属性或属性组合称为该关系的主关键字。**一个数据表中只能有一个主键**。

完整性约束：

| **完整性约束** | **定义** | **示例** | **作用** |
| -------------- | -------- | -------- | -------- |
| **实体完整性** | 每个表的**主键必须唯一且不能为空** | 每个学生的学号必须唯一且不能为空。 | 防止数据重复和记录缺失。 |
| **参照完整性** | **外键引用的主表记录必须存在**，防止孤立引用。 | 选课表中，`student_id` 外键必须对应学生表中的某个 `student_id`。 | 确保数据之间的关系一致性。 |
| **用户自定义完整性** | 根据**业务需求自定义**的约束条件。 | 课程学分（`credit`）必须在1到5之间。 | 符合特定业务逻辑的约束，增强数据正确性。 |
> 外键值可以为空

函数依赖：

| **类型** | **定义** | **示例** | **解释** |
| -------- | -------- | -------- | -------- |
| **完全函数依赖** | 属性集 `Y` 完全依赖于属性集 `X`，且不能去掉 `X` 中的任何属性。 | `学号, 课程号 → 成绩` | 学号和课程号一起决定成绩。去掉其中一个就无法唯一确定成绩。|
| **部分函数依赖** | 属性集 `Y` 依赖于属性集 `X`，但 `X` 中的某些属性可以单独决定 `Y`。 | `学号, 姓名 → 班级` | 这里`学号`本身就可以唯一确定`班级`，`姓名`是冗余的。|
| **传递函数依赖** | 如果 `X → Y` 且 `Y → Z`，则 `X → Z` 成立，为传递依赖。 | `学号 → 班级`, `班级 → 辅导员`，则 `学号 → 辅导员`。 | 学号可以间接决定辅导员信息。 |

候选码：候选码是能唯一标识表中每一条记录的属性集。

主码：主码是从候选码中选择的一个作为主要标识。它是关系表的主要唯一标识符，不允许为空。

全码：全码是**包含候选码的超集**，即可以唯一标识表中记录的属性集。

包含在任一候选码中的属性被称为主属性。

| **范式** | **定义** | **要求** | **解决的问题** | **示例** |
| -------- | -------- | -------- | -------------- | -------- |
| **第一范式 (1NF)** | 所有字段的值必须是**原子值**，即不可再分。 | 每列的数据都是**不可再拆分**的单一值。 | 消除重复组，确保每个字段只存储一个值。 | `地址`列应拆分为`省份`、`城市`等。 |
| **第二范式 (2NF)** | 满足 1NF，并且每个非主属性**完全依赖**于候选码。 | 消除**部分依赖**（即某些非主属性仅依赖于主键的一部分）。 | 避免插入和删除异常。 | 如果表的主键是`学号+课程号`，则`姓名`应移到单独的学生表中。 |
| **第三范式 (3NF)** | 满足 2NF，且所有非主属性都**直接依赖**于主键，而不是通过传递依赖。 | 消除**传递依赖**（非主属性依赖于另一个非主属性）。 | 避免数据冗余和更新异常。 | `学号 → 班级`，`班级 → 辅导员`，应将班级和辅导员信息拆分成独立表。 |

### SQL 结构化查询语言

#### DDL (数据定义语言)

DDL用于定义数据库的结构和模式。主要操作包括：

##### 创建对象

```sql
CREATE DATABASE mydb;
CREATE TABLE employee (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    salary DECIMAL(10,2)
);
CREATE INDEX idx_name ON employee(name);
CREATE VIEW high_salary AS SELECT * FROM employee WHERE salary > 50000;
```

##### 修改对象

```sql
ALTER TABLE employee ADD COLUMN department VARCHAR(50);
ALTER TABLE employee MODIFY COLUMN salary DECIMAL(12,2);
ALTER TABLE employee DROP COLUMN department;
```

##### 删除对象

```sql
DROP TABLE employee;
DROP INDEX idx_name ON employee;
DROP VIEW high_salary;
DROP DATABASE mydb;
```

#### DML (数据操作语言)

DML用于操作数据库中的数据。主要操作包括：

##### 插入数据

```sql
INSERT INTO employee (id, name, salary) VALUES (1, 'John Doe', 60000);
INSERT INTO employee SELECT * FROM temp_employees;
```

##### 更新数据

```sql
UPDATE employee SET salary = 65000 WHERE id = 1;
UPDATE employee SET salary = salary * 1.1 WHERE department = 'IT';
```

##### 删除数据

```sql
DELETE FROM employee WHERE id = 1;
DELETE FROM employee WHERE salary < 30000;
# 删除所有记录，但保留表的结构，可以回滚，记录日志
DELETE FROM table_name;
# 一次性清空表的所有记录，效率比高，不能回滚，不记录日志
TRUNCATE TABLE table_name;
```

##### 查询数据

| **关键字** | **作用** | **常见用法** | **示例** |
| ---------- | -------- | ------------ | -------- |
| **`FROM`** | 指定查询的数据来源（表或视图）。 | `SELECT * FROM table_name` | `SELECT * FROM student;` |
| **`WHERE`** | 指定查询条件，过滤数据。 | `WHERE condition` | `SELECT * FROM student WHERE age > 18;` |
| **`GROUP BY`** | 将结果按某一列或多列分组，并对分组后的数据进行聚合。 | `GROUP BY column_name` | `SELECT age, COUNT(*) FROM student GROUP BY age;` |
| **`ORDER BY`** | 对查询结果按某列升序或降序排序。 | `ORDER BY column_name [ASC \ DESC]`  |`SELECT name, COUNT(*) FROM student ORDER BY salary DESC`|


```sql
SELECT name, salary FROM employee WHERE department = 'Sales' ORDER BY salary DESC;
SELECT department, AVG(salary) AS avg_salary FROM employee GROUP BY department HAVING avg_salary > 50000;
```

WHERE：在数据分组前过滤数据，不能使用聚合函数。

**HAVING：在数据分组后过滤数据，通常与聚合函数结合使用。**

`%`  匹配**零个或多个字符**  `'A%'` 匹配以 A 开头的任意字符串（如 `Alice`、`Anna`）。

`_`  匹配**单个任意字符**  `'B_n'` 匹配 `Ben` 或 `Bin`，但不匹配 `Benn`。

`[abc]`  匹配**集合中的任意一个字符**  `'B[aeiou]n'` 匹配 `Ban`、`Ben`、`Bin` 等。

`[a-z]`  匹配**字符范围内的任意字符**  `'T[a-c]m'` 匹配 `Tam`、`Tbm` 或 `Tcm`。

`[^]`  **不匹配**集合中的字符  `'T[^aeiou]m'` 匹配 `Tbm`、但不匹配 `Tam`。



#### DCL (数据控制语言)

DCL用于控制数据库的访问权限和事务处理。主要操作包括：

##### 授予权限

```sql
GR ANT SELECT, INSERT ON employee TO user1;
GRANT ALL PRIVILEGES ON mydb.* TO user2;
```

##### 撤销权限

```sql
REVOKE INSERT ON employee FROM user1;
REVOKE ALL PRIVILEGES ON mydb.* FROM user2;
```

##### 事务控制

```sql
START TRANSACTION;
-- 执行一系列操作
COMMIT;  -- 提交事务
-- 或
ROLLBACK;  -- 回滚事务
```

#### 数据库高级

##### 索引

```sql
CREATE INDEX idx_employee_name ON employee(name);
```

##### 存储过程

存储过程是预编译的SQL语句集合：
```sql
DELIMITER //
CREATE PROCEDURE get_employee_by_id(IN emp_id INT)
BEGIN
    SELECT * FROM employee WHERE id = emp_id;
END //
DELIMITER ;

CALL get_employee_by_id(1);
```

##### 触发器

触发器在特定事件发生时自动执行：
```sql
CREATE TRIGGER before_employee_update
BEFORE UPDATE ON employee
FOR EACH ROW
SET NEW.last_updated = NOW();
```

使用触发器，可以保证数据库的完整性，减少程序的代码，降低开发难度。



##### 视图

视图是基于SQL语句的结果集的可视化的表：
```sql
CREATE VIEW employee_summary AS
SELECT department, COUNT(*) as employee_count, AVG(salary) as avg_salary
FROM employee
GROUP BY department;
```

##### 事务

事务确保了数据的一致性和完整性：
```sql
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

##### 连接查询

**LEFT JOIN：保留左表的所有记录**，即使右表没有匹配的记录，不匹配部分用 **NULL** 填充。

**RIGHT JOIN：保留右表的所有记录**，即使左表没有匹配的记录，不匹配部分用 **NULL** 填充。

**INNER JOIN：只返回两个表中匹配的记录**，即只有在两个表的连接条件满足时才返回数据。

连接查询用于从多个表中检索数据：
```sql
SELECT e.name, d.department_name
FROM employee e
INNER JOIN department d ON e.department_id = d.id;
```

这些概念和操作构成了数据库管理和使用的核心。熟练掌握这些操作可以帮助有效地设计、管理和操作数据库系统。




### 数据库管理

#### 事务管理

事务是用户定义的一组操作序列的集合，是数据恢复和并发控制的基本单位。事务的4个特性：

1. **原子性**：事务的所有操作在数据库中要么全做，要么全都不做。
2. **一致性**：一个事务独立执行的结果是将保持数据的一致性，即数据不会因为事务的执行而遭受破坏。
3. **隔离性**：一个事务的执行不能被其它事务干扰。
4. **持久性**：一个事务一旦提交，它对数据的改变是永久的。

数据库系统在执行事务时，要么执行事务中全部操作，要么一个操作都不执行。一个应用程序往往由若干个独立的事务组成。在SQL中用户显示定义事务的语句有下3条：
```mysql
# 该语句显式地定义一个事务的开始
Begin Transaction;
# 该语句显式地提交一个事务，并表示该事务已正常结束
Commit;
# 该语句显式地回滚一个事务，且表示事务因执行失败而结束
ROLLBACK;
```

所谓并发操作是指在多用户共享的系统中，许多用户可能同时对同一数据进行操作。并发操作带来问题的原因是事务的并发操作破坏了事务的隔离性。DBMS的并发控制子系统负责协调并发控制事务的执行，保证数据库的完整性不受破坏，避免用户得到不正确的数据。

并发操作带来的数据不一致性有3类：**丢失修改、不可重复读和读“脏数据”**。

1. **丢失的修改**：事物A和B读入同一数据并修改，B提交的结果破坏了A提交的结果，导致A的修改被丢失。
2. **不可重复读**：事物A读取某一数据后，事物B对其作了修改，当事物A再次读取数据时，得到与前一次不同的值。
3. **脏读**：事物A修改某一数据，并将其写回磁盘，事物B读取同一数据后，A由于某种原因被撤销，这时A已修改过的数据恢复原值，B读到的数据就与数据库中的数据不一致，则B读到的数据为“脏”数据，即不正确的数据。

产生上述三类数据不一致性的主要原因是并发操作破坏了事物的隔离性，并发控制就是要用正确的方式调度并发操作，使一个事物的执行不受其他事物的干扰，从而避免造成数据的不一致性。

并发控制的而主要技术是封锁：

1. 排他锁 (X锁)
   - **定义**：当一个事务获得排他锁时，**其他事务不能再对被锁定的数据进行任何类型的锁定**，包括共享锁和排他锁。
   - **使用场景**：用于执行写操作（如插入、更新和删除），确保数据的独占性。
   - **优点**：确保了数据的一致性，防止其他事务对相同数据进行读或写操作。
   - **缺点**：可能导致死锁情况和较高的等待时间，因为其他事务在排他锁释放之前无法访问被锁定的数据。
2. 共享锁 (S锁)
   - **定义**：当一个事务获得共享锁时，其他事务可以对相同的数据行获得共享锁，但不能获得排他锁。**这意味着其他事务可以读取数据，但不能修改。**
   - **使用场景**：用于执行读操作，**允许多个事务同时读取同一数据，而不允许修改**。
   - **优点**：允许多个事务同时读取数据，提高了并发性。
   - **缺点**：写操作会被阻止，直到所有共享锁都被释放，可能导致写操作的延迟。

#### 数据库备份与恢复

造成数据损失的原因：**存储介质故障、用户的错误操作、服务器彻底崩溃**。数据库的备份设备主要有**磁盘备份设备、磁带备份设备、命名管道设备**。

备份方式包括**完全备份、差异备份、日志备份、增量备份**。恢复模式包括**简单恢复模式、完整恢复模式和大容量日志恢复模式**。

**日志文件是用于记录数据库的所有更新操作。**

| 备份类型 | 描述 | 优点 | 缺点 |
| -------- | ---- | ---- | ---- |
| 完全备份 | 备份所有数据的完整副本。 | 恢复简单，数据完整。 | 备份时间长，占用大量存储空间。 |
| 差异备份 | 备份自**上次完全备份**以来所有更改的数据。但是不包括日志。 | 恢复速度较快，备份空间比完全备份小。 | 备份时间较长，随着时间推移备份文件增大。 |
| 增量备份 | 备份自上次备份（**可以是完全备份或增量备份**）以来所有更改的数据。 | 占用存储空间最小，备份速度最快。 | 恢复时需要最后一次完全备份和所有增量备份，过程复杂。 |
| 日志备份 | 备份数据库的日志文件，以便可以恢复到特定时间点。 | 可恢复到任意时间点，适合对数据一致性要求高的场景。 | 日志文件需要管理，恢复过程较为复杂。 |

数据库中的4类故障：**内部故障、系统故障、介质故障和计算机病毒**。

数据恢复的基本原理是“建立冗余数据”(重复存储)。建立冗余数据的方法是进行**数据转储和登记日志文件**。数据转储分为静态转储和动态转储、海量转储和增量转储。

数据库运行一段时间后，由于记录不断的增删改，会使数据库的物理存储情况变坏，降低了数据的存取效率。此时就需要对数据库进行重新安排存储位置，回收垃圾、减少指针链等的再组织。而当数据库增加新的实体，取消了某些应用后，原有的数据库设计不能满足要求，就要对其进行重构造，调整数据库的模式或外模式。故数据库管理员对数据进行再**组织和重构**。



#### 数据库优化

数据库优化可以从**架构优化、硬件优化、DB优化、SQL优化**四个维度入手。

##### 架构优化

一般来说在高并发的场景下对架构层进行优化其效果最为明显，常见的优化手段有：**分布式缓存，读写分离，分库分表**等，每种优化手段又适用于不同的应用场景。

1. **分布式缓存**：将数据缓存在内存中（如 **Redis** 或 **Memcached**），减少数据库的直接访问，提高响应速度。
2. **读写分离**：通过将**读操作**和**写操作**分开到不同的数据库实例上，缓解数据库的压力。通常结构为**一个主库（Master）负责写入**，**多个从库（Slave）负责读取**。
3. **分库分表**：将数据按照一定规则进行拆分，**分库**是将数据拆分到不同的数据库实例中，**分表**是将表数据拆成多张表存储。

##### 硬件优化

使用数据库，不管是读操作还是写操作，最终都是要访问磁盘，所以说磁盘的性能决定了数据库的性能。但是**磁盘I/O速度与磁盘容量无关，将磁盘升级到更大容量并不能提高磁盘I/O速度。**

**磁盘镜像会减慢磁盘读写的速度。**

**磁盘读写进度对数据库系统是至关重要的，数据库对象在物理设备上的合理分布能改善性能。**

##### DB优化

数据库实例参数优化遵循三句口诀：日志不能小、缓存足够大、连接要够用。

日志跟缓存对数据库实例尤其重要。而连接如果不够用，数据库会直接抛出异常，系统无法访问。

由于CPU和内存的速度远大于硬盘的读写速度，所以可以把不同的数据文件放在不同的物理硬盘里，这样执行查询的时候，就可以让多个硬盘同时进行查询，以充分利用CPU和内存的性能，提高查询速度，通常建议**将数据文件和日志文件存储在不同的磁盘分区或物理硬盘上：**

- **数据文件：** 放在读写速度较快的磁盘，以优化查询和写入性能。
- **日志文件：** 放在独立的磁盘上，以减少 IO 冲突，提升事务处理速度。

> 数据库都具有事务日志，用于记录所有事务以及每个事务对数据库所做的修改。任何写操作都需要记录日志，因此一旦数据库日志满了，不能执行更改、备份等写操作，只能执行查询等读操作。

##### SQL优化

1. 合理使用索引：提高查询速度，加速 `ORDER BY` 和 `WHERE` 子句的处理，提高多表连接速度，索引的建立要在查询和DML性能之间取得平衡。**在索引列上做计算、函数、类型转换，会导致索引失效而转向全表扫描**，如substr（）。
2. 使用**UNION ALL替代UNION**，因为UNION执行时需要排重。
3. **避免select *写法**，执行SQL时优化器需要转成具体的列，每次查询都要回表，不能走覆盖索引。
4. 避免复杂SQL语句。



## 数据挖掘

数据仓库是一个面向主题的、集成的、相对稳定的，用于存储大量的历史数据，反映历史变化的数据集合，用于支持管理决策，支持企业进行数据分析、报表和商业智能（BI）。它不同于传统数据库，更关注于查询性能和数据分析，而非事务处理。把**信息加以整理、归纳和重组,并及时提供给对应的管理决策人员是数据仓库的根本任务**。数据仓库的特点：

1. 数据仓库是面向主题的。
2. 数据仓库是集成的。
3. 数据仓库的数据是随着时间的变化而变化的。数据库随着时间变化不断删去旧的数据内容。
4. 数据仓库的数据是不可修改的。

**数据清洗**，从名字上也看得出就是把“脏”的“洗掉”，是指发现并纠正数据文件中可识别的错误的最后一道程序，包括检查数据一致性，处理无效值和缺失值等。不符合要求的数据主要是有**不完整的数据、错误的数据、重复的数据**三大类。**对于异常数据要慎重处理，有可能是错误数据，但也有可能是正确的非常重要的超常数据**。分析处理异常数据需要专业水平，不属于数据清洗工作。

**OLTP** 和 **OLAP** 是两种常见的数据处理系统。它们各自针对不同的业务需求设计，分别用于事务处理和数据分析。

- OLTP 是一种面向实时事务处理的系统，用于处理日常的业务操作，如订单管理、用户注册和支付处理。

- OLAP 是一种面向数据分析和决策支持的系统，用于处理大量历史数据，支持复杂查询，如统计、汇总和趋势分析。OLAP系统的核心在于对多维数据进行探索和分析。它主要通过**钻取**、**切片和切块**、**旋转**等操作，帮助用户从不同角度挖掘数据，进行深入分析。
  - **钻取**：从年度销售数据“下钻”到季度、月份，再到具体日期的销售数据。从城市级别的销售额“上卷”到省份或国家级别。
  - **切片**：选择 2024 年的数据进行分析（锁定时间维度的一部分）。
  - **切块**：选择“2024 年” + “北美区域” + “电子产品”这几个维度的交集数据。
  - **旋转**：将“时间”维度从行切换到列，或者将“产品”维度与“区域”维度交换位置。

数据仓库的结构通常包含**数据仓库服务器、OLAP服务器、前端分析工具**等三个层次。来实现数据的集成、存储和分析。这种架构有效地将数据从业务系统转化为可供分析的数据，保证了数据的一致性、完整性和高效性。

- 在数据仓库的结构中，数据源是数据仓库的基础，通常包括企业内部信息和外部信息。
- 数据的存储与管理是整个数据仓库的核心。
- OLAP服务器对分析需要的数据进行有效集成，按多维模型组织，以便多角度、多层次地分析，并发现趋势。
- 前端工具主要包括各种报表工具、查询工具、数据分析工具、数据挖掘工具以及各种基于数据仓库或数据集市的应用开发工具。

通常，**数据仓库** 会从 OLTP 系统中抽取数据，通过 **ETL（Extract-Transform-Load）**流程将其转换为分析所需的格式，再提供给 OLAP 系统进行查询和分析。**ETL是构建数据仓库的重要一环，用户从数据源抽取出所需的数据，经过数据清洗，最终按照预先定义好的数据仓库模型，将数据加载到数据仓库中去。**

**DataMining即数据挖掘**，是指在大型数据存储库中，自动地发现有用信息的过程。

主要步骤：**数据收集与清洗、数据预处理、模型构建、模型评估、结果分析与应用**。

| 算法类别 | 常用算法 | 适用场景 |
| -------- | -------- | -------- |
| 分类 | 决策树、SVM、KNN、逻辑回归 | 客户分类、垃圾邮件检测 |
| 回归 | 线性回归、Lasso回归 | 预测房价、销量预测 |
| 聚类 | K-means、DBSCAN、层次聚类 | 用户分群、市场细分 |
| 关联规则 | Apriori、FP-Growth | 商品推荐、购物篮分析 |
| 降维 | 主成分分析、t-SNE | 可视化、高维数据分析 |
